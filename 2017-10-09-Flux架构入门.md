# Flux 架构入门教程

### 一、Flux 是什么？

>简单说，Flux 是一种架构思想，专门解决软件的结构问题。它跟MVC 架构是同一类东西，但是更加简单和清晰。
>Flux存在多种实现（至少15种），本文采用的是Facebook官方实现。
### 二、安装 Demo
    $ git clone https://github.com/ruanyf/extremely-simple-flux-demo.git
    $ cd extremely-simple-flux-demo && npm install
    $ npm start
>然后，访问 http://127.0.0.1:8080
    ![img](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011502.png)

>你会看到一个按钮。这就是我们的Demo。
### 三、基本概念
 首先，Flux将一个应用分成四个部分。

> + View： 视图层
> + Action（动作）：视图层发出的消息（比如mouseClick）
> + Dispatcher（派发器）：用来接收Actions、执行回调函数
> + Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

![img](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png)

 Flux 的最大特点，就是数据的"单向流动"。
> 1. 用户访问 View
> 2. View 发出用户的 Action
> 3. Dispatcher 收到 Action，要求 Store 进行相应的更新
> 4. Store 更新后，发出一个"change"事件
> 5. View 收到"change"事件后，更新页面

  上面过程中，数据总是"单向流动"，任何相邻的部分都不会发生数据的"双向流动"。这保证了流程的清晰。
读到这里，你可能感到一头雾水，OK，这是正常的。接下来，我会详细讲解每一步。

### 四、View（第一部分)
 请打开 Demo 的首页index.jsx ，你会看到只加载了一个组件。

```java
// index.jsx
var React = require('react');
var ReactDOM = require('react-dom');
var MyButtonController = require('./components/MyButtonController');

ReactDOM.render(
  <MyButtonController/>,
  document.querySelector('#example')
);

```
 上面代码中，你可能注意到了，组件的名字不是 MyButton，而是 MyButtonController。这是为什么？
这里，我采用的是 React 的 controller view 模式。"controller view"组件只用来保存状态，然后将其转发给子组件。MyButtonController的源码很简单。

```java
// components/MyButtonController.jsx
var React = require('react');
var ButtonActions = require('../actions/ButtonActions');
var MyButton = require('./MyButton');

var MyButtonController = React.createClass({
  createNewItem: function (event) {
    ButtonActions.addNewItem('new item');
  },

  render: function() {
    return <MyButton
      onClick={this.createNewItem}
    />;
  }
});

module.exports = MyButtonController;

```
 上面代码中，MyButtonController将参数传给子组件MyButton。后者的源码甚至更简单。
 
 ```java
 // components/MyButton.jsx
var React = require('react');

var MyButton = function(props) {
  return <div>
    <button onClick={props.onClick}>New Item</button>
  </div>;
};

module.exports = MyButton;
 ```
 上面代码中，你可以看到MyButton是一个纯组件（即不含有任何状态），从而方便了测试和复用。这就是"controll view"模式的最大优点。
MyButton只有一个逻辑，就是一旦用户点击，就调用this.createNewItem 方法，向Dispatcher发出一个Action。
```java
// components/MyButtonController.jsx

  // ...
  createNewItem: function (event) {
    ButtonActions.addNewItem('new item');
  }
```
上面代码中，调用createNewItem方法，会触发名为addNewItem的Action。